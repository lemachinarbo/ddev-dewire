#!/usr/bin/env bash
#ddev-generated
# Schema-driven GitHub environment setup with wizard mode
# Usage: dw-gh-env [ENV] [--debug] [--lazy] [--dry-run]

set -euo pipefail

# Script directory and main env file
SCRIPT_DIR="$(dirname "$0")"
readonly SCRIPT_DIR
readonly ENV_FILE=".env"
source "${SCRIPT_DIR}/lib/common.sh"

# Import the new libraries
source "${SCRIPT_DIR}/lib/schema-parser.sh"
source "${SCRIPT_DIR}/lib/env-validator.sh"
source "${SCRIPT_DIR}/lib/env-wizard.sh"
source "${SCRIPT_DIR}/lib/github-uploader.sh"
source "${SCRIPT_DIR}/lib/env-loader-simple.sh"

# Global flags
DEBUG=false
LAZY_MODE=false
SETUP_MODE="" # Will be auto-detected if not set
PARSED_ARGS=()

show_help() {
  cat <<EOF
dw-gh-env: Schema-driven GitHub environment setup with wizard mode
Usage: ddev dw-gh-env [ENV] [--debug] [--lazy] [--dry-run] [--verbose]

Options:
  --debug      Show detailed debug information
  --lazy       Accept all defaults without prompting
  --dry-run    Skip GitHub upload (for testing)
  --verbose    Show extra info output
EOF
}

main() {
  export NO_COLOR=1
  parse_args "$@"
  log_header "Environment Setup"
  log_info "Weâ€™ll prepare a local .env file with settings for your environments."

  choose_setup_mode

  # Always check/fix completeness after mode selection
  if [[ -f $ENV_FILE && -s $ENV_FILE ]]; then
    # Parse schema to check completeness for selected mode
    parse_env_schema false
    debug "After parse_env_schema: LOCAL_REQUIRED_VARS has ${#LOCAL_REQUIRED_VARS[@]} items"
    if ! is_env_complete "$ENV_FILE"; then
      debug "File is incomplete, backing up and fixing..."
      backup_env_file
      fix_incomplete_env "$ENV_FILE"
    fi
  else
    # Generate new .env file for selected mode
    parse_env_schema false # Parse schema for wizard mode
    case "$SETUP_MODE" in
    env | local | all)
      generate_env_for_mode
      ;;
    *)
      log_error "Unknown setup mode: $SETUP_MODE"
      exit 1
      ;;
    esac
  fi

  load_selected_environment
  upload_to_github
}

# CLI parsing and debug helpers
parse_args() {
  while (($# > 0)); do
    case "$1" in
    --help)
      show_help
      exit 0
      ;;
    --debug)
      DEBUG=true
      ;;
    --lazy)
      LAZY_MODE=true
      ;;
    --dry-run)
      DRY_RUN=true
      ;;
    --verbose)
      VERBOSE=true
      ;;
    -*)
      log_error "Unknown option: $1"
      exit 1
      ;;
    *)
      PARSED_ARGS+=("$1")
      ;;
    esac
    shift
  done
  export DEBUG DRY_RUN LAZY_MODE VERBOSE
}

# Backup env file if it exists and is non-empty
backup_env_file() {
  if [[ -f $ENV_FILE && -s $ENV_FILE ]]; then
    TIMESTAMP=$(date +"%Y%m%d%H%M%S")
    log_info "Backing up existing $ENV_FILE to $ENV_FILE.backup.$TIMESTAMP"
    cp $ENV_FILE "$ENV_FILE.backup.$TIMESTAMP"
  fi
}

# Generate environment via wizard for selected mode
generate_env_for_mode() {
  wizard_mode
  export WIZARD_COMPLETED=true
}

# Load selected environment
load_selected_environment() {
  local env_arg="${PARSED_ARGS[0]:-}"

  # Skip validation if wizard just completed, but always validate for existing .env
  debug "WIZARD_COMPLETED=${WIZARD_COMPLETED:-false}, SETUP_MODE=${SETUP_MODE:-unset}"

  local load_options=""
  if [[ "${WIZARD_COMPLETED:-false}" == true ]]; then
    load_options="--skip-validation --skip-schema-parse"
  else
    load_options="--skip-schema-parse" # Schema already parsed in main
  fi

  # Add local mode flag only for local-only mode
  if [[ "${SETUP_MODE:-}" == "local" ]]; then
    load_options="$load_options --local"
  fi

  load_environment "$env_arg" "$load_options"
}

# Upload to GitHub (or dry run)
upload_to_github() {
  if [[ "${DRY_RUN:-false}" == true ]]; then
    log_ok "Dry run mode - skipping GitHub upload"
  else

    if [[ "$LAZY_MODE" != true ]]; then
      log_ask "Proceed with upload? [Y/n]: "
      read -r confirm
      confirm=${confirm:-y}
      if [[ ! "$confirm" =~ ^[Yy] ]]; then
        log_info "Upload cancelled by user."
        return 1
      fi
    fi
    upload_github_data
  fi
}

wizard_mode() {
  log_header "DeWire Environment Setup Wizard v4"
  # Determine which env file to use
  local env_file="$ENV_FILE"
  if [[ ! -f $env_file ]]; then
    log_info "No $env_file found. Setting up environment."
  elif [[ ! -s $env_file ]]; then
    log_info "Empty $env_file found. Setting up environment."
  else
    log_info "Incomplete $env_file found. Completing setup."
  fi

  # Don't parse schema again - already parsed in main
  log_ok "Schema loaded: ${#REQUIRED_VARS[@]} required, ${#LOCAL_REQUIRED_VARS[@]} local, ${#ENV_REQUIRED_VARS[@]} env variables"

  if [[ -f ${ENV_FILE}.setup ]]; then
    log_ok "Loading values from ${ENV_FILE}.setup"
    env_file="${ENV_FILE}.setup"
  fi

  # Parse DEWIRE behavior flags
  local dewire_allow dewire_ask
  if ! dewire_allow=$(get_env_var "" "DEWIRE_ALLOW_CUSTOM_VARS" "$env_file" 2>/dev/null); then
    dewire_allow="true"
  fi
  if ! dewire_ask=$(get_env_var "" "DEWIRE_ASK_ON_CUSTOM_VARS" "$env_file" 2>/dev/null); then
    dewire_ask="true"
  fi
  export DEWIRE_ALLOW_CUSTOM_VARS="$dewire_allow"
  export DEWIRE_ASK_ON_CUSTOM_VARS="$dewire_ask"

  # Don't call choose_setup_mode again - already set in main
  generate_env

  # After generation, load the main env file
  local load_opts="--skip-validation --skip-schema-parse" # Schema already parsed above
  [[ "${SETUP_MODE:-}" == "local" ]] && load_opts="$load_opts --local"
  load_environment "${PARSED_ARGS[0]:-}" "$load_opts"
}

main "$@"
